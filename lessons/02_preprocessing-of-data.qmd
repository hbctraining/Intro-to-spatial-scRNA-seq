---
title: "Pre-processing of Spatial Data"
authors: "Will Gammerdinger, Noor Sohail, Zhu Zhuo, James Billingsley, Shannan Ho Sui"
date: "Tuesday, July 22, 2025"
editor_options: 
  markdown: 
    wrap: 72
---

Approximate time: XY minutes

# Learning Objectives

-   Describe the data set that we will be using for this analysis
-   Read in the data to a Seurat object
-   Discuss the slots in the Seurat object that have been filled after reading in the data

# The Dataset

TODO

## Metadata

::: {.panel-tabset}

### Human CRC

Matched control and cancerous colon sample from 58 year old female in stage IV-A.

-   [Natural (control)](https://www.10xgenomics.com/platforms/visium/product-family/dataset-human-crc)
-   [Colorectal Cancer](https://www.10xgenomics.com/platforms/visium/product-family/dataset-human-crc)


### Mouse Brain

A mouse brain (fresh frozen) was obtained from Charles River Laboratories.

Strain: C57BL/6 Sex: Male Age: 8 weeks Sample preparation

A 10 µm section was taken with a cryostat (Epredia CryoStar NX70). Tissue block preparation, sectioning, H&E staining, and imaging followed the Visium HD Fresh Frozen Tissue Preparation Handbook (CG000763).

The data was subset to a smaller cross-section of the brain in order to make it more manageable on local laptops. The instructions for how to subset a 10X Visium HD slides can be found [here](Aside_subsetting_slide.qmd).

:::

## Downloading the R Project and Data

We have assembled an R Project for you to download that includes the data along with a basic file structure for maintain good data management. It can be quite easy when starting a new analysis to want to dive right in and start analyzing your data. However, good data management practices occur at each step of data's lifecycle. It is a good habit to begin by creating a basic directory structure to hold your data. Let's start by download this R Project and data from [here](). Left-click on the link and select `Save Link As..` or `Download Linked File As..`, then select a place on your computer where you would like to place this R Project.

We can open the R Project up and see that the provided file structure should look like:

```{r}
#| label: file_structure
#| echo: false
library(fs)

# Print the first level in the downloaded directory
# dir_tree("data", recurse = 1)
```

If your R Project looks like below, then you are ready to start!

TODO: **Insert picture of what the R Project will look when it is ready to start**

::: callout-tip
# [**Exercise 1**](02_preprocessing-of-data_Answer-key.qmd#exercise-1)

Given the information that we know from the metadata, what might be some questions that we are interested in interrogating using our data?
:::


```{r}
#| label: header_libraries
# Loading spatial files
# Dec 2025

library(tidyverse)
library(Seurat)
```

# Loading Data into a Seurat Object

There are two main tools used for analyzing single-cell RNA-seq data, Python's [scanpy](https://scanpy.readthedocs.io/en/stable/) and R's [Seurat](https://satijalab.org/seurat/). While both tools have nuances that the other doesn't have, they have many functionalities in common. As this in an R-based workshop, we will be using Seurat. 

## Data Files

To load our data, we are going to make use of the function `Load10X_Spatial()`. The input needed for this function comes from the output generated by SpaceRanger, including both the feature matrix and low-resolution tissue image. Once supplied, a Seurat object with both gene-level counts and spatial information is created. 

There are 3 main arguments that we will be utilizing for this step:

| Argument | Description |
|---------|-------------|
| data.dir | Directory containing the H5 file specified by filename and the image data in a subdirectory called spatial |
| bin.size | Specifies the bin sizes to read in (defaults to c(16, 8)) |
| slice    | Name for the stored image of the tissue slice |

::: {.callout-note collapse=true}
# Using `?` to look up function arguments 
If you are ever unsure what parameters you can supply to a function, you make use of the `?` call in R. This will bring up the manual page for the function while will provide more details on what each variable is used for.

```{r}
#| label: function_man_page
#| eval: false
?Load10X_Spatial
```
:::

Before loading in the data, let us take a look at the files that are generated by SpaceRanger. In particular, let us take a look at sample `data/P5CRC` which is the path would supply as `data.dir` in the `Load10X_Spatial()` function.
 
```{r}
#| label: spaceranger_outs
#| echo: false
dir_tree("data/P5CRC/", recurse = 1)
```

In the Visium HD assay, in addition to providing data at the level of the 2µm x 2µm squares, SpaceRanger also bins the 2µm x 2µm squares into 8µm x 8µm and 16µm x 16µm bins. **We can see each of these different resolution inside the `binned_outputs` folder.**

While the single-digit micron resolution is a big technological improvement over original Visium’s original ∼55μm spots, the higher resolution also presents challenges. 

| Pro                                                         | Con                                                           |
|-------------------------------------------------------------|---------------------------------------------------------------|
| Reconstructing single cells from the data, so each spot is one cell | Very small 2µm × 2µm (and 8µm × 8µm) bins may capture very little biological signal |
| Continuous expression values across the entire tissue        | Large numbers of bins increase computational time and resource requirements |

::: callout-important
# Choosing your bin size
TODO

- Depends on the size of cells in your dataset
- Mention that we will discuss segmentation more in future lessons
:::

## Creating the Seurat Object

Now that we understand the input needed for the `Load10X_Spatial()` function, let's use it to create a Seurat object called `crc`. We will specify that we want to load in the `8um` and `16um` bin sizes at the same time. **Typically you would only load in one bin size, but for the purposes of better understanding bins and our Seurat object we will load both here.**

```{r}
crc <- Load10X_Spatial(
  data.dir = "data/P5CRC/",
  bin.size = c(8, 16),
  slice = "P5CRC")
```

Now we can examine its major features, which we will add to and alter throughout the lesson:

```{r}
crc
```

## Anatomy of a Seurat Object

As we can see from our Seurat callout, there are a lot of different parts inside our object. Here, we will go through each of the major components of a Seurat object and how you would access certain pieces of information.

::: {.panel-tabset}

### Assays

`Assays` are where we can store different counts matrices - we are not forced to keep the same features and variable genes across assays. Each assay will contain it's own `Layers` that can be distinct from other assays in the object. This is useful in several different instances:

- Multi-modal assays, where you can keep the expression matrices for RNA, ATAC, or protein in a single Seurat object
- Storing counts matrices from a variety of different normalization techniques
- Batch integration methods will sometimes generate a transformed counts matrix

Here we can print the different assays that exist within our `crc` object:

```{r}
Assays(crc)
```

We have to separate assays for the different bin sizes, which makes sense because we have different count matrices for our cells based upon the bin size that was selected.

The `DefaultAssay()` function shows us which assay information will be used in other Seurat function calls, unless explicitly stated specific otherwise.

```{r}
DefaultAssay(crc)
```

We can also change what our default assay is. Let's set it to the `016um` bins:

```{r}
DefaultAssay(crc) <- "Spatial.016um"
crc
```
Now we see that the callout says: `Active assay: Spatial.016um `

### Features and Cells

Our count matrices function as any other matrix does, with rows and columns. 

In Seurat, the rows correspond to `Features`. In the case of spatial transcriptomics, our features are genes. In other experiments, features could refer to chromatin peaks or protein. Since our features are not always genes, we will see the term `Feature` appear in Seurat function later. The important thing to recall is that in this Visium HD dataset, we are quantifying RNA expression (genes).

We can see what the first few genes in our count matrix are:

```{r}
Features(crc) %>% head()
```

As well as see the number of genes that are found in each of our assays:

```{r}
nrow(crc[["Spatial.008um"]])
nrow(crc[["Spatial.016um"]])
```


In Seurat, the rows correspond to `Cells` (or samples as it appears in the callout). 

We can see what the first few cells in our count matrix are:

```{r}
Cells(crc) %>% head()
```

As well as see the number of cells that are found in each of our assays:

```{r}
ncol(crc[["Spatial.008um"]])
ncol(crc[["Spatial.016um"]])
```

::: callout-important
# Bin size
Did you notice that the number of cells is different between our `8um` and `16um` bins?

This is why the bin value matters, it determines how many "cells" are ultimately generated. Where a smaller bin size results in more spots.
:::



### Layers

Layers are our count matrices. 

```{r}
Layers(crc)
```

By default, Seurat uses the following naming convention for the counts matrices within an `Assay`: 

| Layer       | Description                     |
|-------------|---------------------------------|
| counts      | Raw counts                      |
| data        | Normalized counts               |
| scale.data  | Scaled‑normalized counts        |

You may notice that our Seurat object only contains `counts` right now. This is because we have not run any normalization steps yet (we will discuss how to do so in future lessons).

Using the `LayerData()` function we can access the entire counts matrix. Furthermore, we can specify the `assay` if we would prefer to not use the `DefaultAssay`.

```{r}
LayerData(crc, 
          assay = "Spatial.016um", 
          layer = "count")[1:5, 1:5]
```
By printing the first 5 features and cells in our object (for easier visualization). We can see that we are working with **whole numbers** which reinforces the idea that this is the **raw data**, with no tranformations having been applied.


### Spatial field

We do not just have expression data associated with our sample, we also have the spatial slide that comes with its own set of values and information.

For example we can grab the x,y coordinates of each spot using the `GetTissueCoordinates()` function.

```{r}
GetTissueCoordinates(crc) %>% head()
```

Or visualize what our slide looks like:

```{r}
SpatialDimPlot(crc)
```

### Metadata

**Seurat automatically creates some metadata** for each of the cells when the object is created. This information is stored in the `@meta.data` slot within the Seurat object. The rownames are automatically set to be the cell names.

```{r}
crc@meta.data %>% head()
```

What does each column represent?

| Column        | Description                                   |
|---------------|-----------------------------------------------|
| orig.ident    | Sample identity if known; defaults to “s”     |
| nCount_RNA    | Number of UMIs per cell                       |
| nFeature_RNA  | Number of genes detected per cell             |

While it may seem intimidating at first, the important thing to remember is that this is a dataframe. Therefore can modify and work with this dataframe just like we would any other in R! For example, we can set our `orig.ident` column to be our sample name rather than "s".

```{r}
crc@meta.data$orig.ident <- "P5CRC"
crc@meta.data %>% head()
```

Additionally, we do not have use the `@meta.data` each time we want to access a column. We can use the `$` to get information from a column.

```{r}
crc$nCount_Spatial.008um %>% head()
```
:::

::: callout-tip
# [**Exercise 2**](02_preprocessing-of-data_Answer-key.qmd#exercise-2)
TODO
Exercise 1
:::

# Loading Multiple Samples into Seurat

Now that we have a better understanding of how to create a Seurat object from SpaceRanger outpus, let's go through how we can load multiple samples at once. In this case we want to represent both samples `P5CRC` and `P5NAT` in a singular Seurat object.

## Using a `for` Loop 

In practice, you will likely have several samples that you will need to read in data for, and that can get tedious and error-prone if you do it one at a time. So, to make the data import into R more efficient we can use a `for` loop, which will iterate over a series of commands for each of the inputs given and create Seurat objects for each of our samples. 

In R, the `for` loop has the following structure/syntax:

```{r}
#| label: for_loop_example
#| eval: false
## DO NOT RUN

for (variable in input){
	command1
	command2
	command3
}
```

Today we will use it to **iterate over the two sample folders** and execute commands for each sample as we did above for a single sample:

1. Create the Seurat objects from the SpaceRanger data (`Load10X_Spatial()`)
2. Set `orig.ident` to be our sample

Once those steps run, we will store the newly generated Seurat object to a list called `list_seurat` so that we can eventually merge both samples together.

**We will be using a bin size of 8um for the remainder of this workshop**

```{r}
samples <- c("P5CRC", "P5NAT")
list_seurat <- list()

for (sample in samples) {
  
  # Path to data directory
  data_dir <- paste0("data/", sample)
  # Create seurat object and set orig ident to be sample
  seurat <- Load10X_Spatial(data.dir = data_dir,
                            bin.size = c(8),
                            slice = sample)
  seurat$orig.ident <- sample
  
  # Store seurat object in our list
  list_seurat[[sample]] <- seurat
}
```

To confirm that we succesfully loaded both samples in, we can take a look at the contents of `list_seurat`.

```{r}
list_seurat
```
Now that we have created both of these objects, let’s take a quick look at the list we just created. We should see that there are two Seurat objects in our list that correspond to each sample. This is exactly what we had hoped to see, so now we can move on to the next step which is merging the sample together int oa singular Seurat object.

::: {.callout-note collapse=true}
# Merging, not Integration
A common point of confusion is the distinction between **integration** and merging. In the field, integration is considered to be modifying either your counts or latent space in a way to correct for a batch variable. Whereas what we are doing now is **merging** or concatenating multiple samples together. This process of merging does not transform the values in the count matrices.
:::

## Merge Datasets Together

We merge samples together because it make it easier to run the QC steps for both sample groups together and enable us to easily compare the data quality for all the cells at one time

We can use the `merge()` function from the Seurat package to achieve this goal. Because the same cell IDs can be used for different samples, we add a **sample-specific prefix** to each of our cell IDs using the `add.cell.id` argument to ensure the cell names are unique.

```{r}
seurat_merged <- merge(x = list_seurat[["P5CRC"]],
                       y = list_seurat[["P5NAT"]],
                       add.cell.id = c("P5CRC", "P5NAT"))
seurat_merged
```
From the callout we can see that we now have: `2 layers present: counts.1, counts.2`

Which we also see represented if we look at our `Layers()`

```{r}
Layers(seurat_merged)
```

However, we do not want to have two distinct raw counts matrices (`counts.1` and `counts.2`. We want the counts for each sample to be concatenated together. This would be a single, large count matrix that represent each cell in the dataset. Seurat's function `JoinLayers()` allows us to do just this.

```{r}
seurat_merged <- JoinLayers(seurat_merged)
seurat_merged
```

Now we have a singular `counts` matrix.

::: {.callout-note collapse=true}
# What if I am merging more than two samples?

Seurat now has functionality to merge many samples together. You can do this quite easily by adding all sample objects to the `y` argument in a vector format. An example is provided below: 

```{r}
#| label: merging_multiple_objects
#| eval: false
## DO NOT RUN
merged_seurat <- merge(x = seurat_list[[1]], 
                       y = seurat_list[[2:length(seurat_list)]],
                       add.cell.id = names(seurat_list))
```       
:::

## Evaluating `merged_seurat`

Let’s also double check that we have the correct number of cells. First, let us see what the number of cells was for each sample:

```{r}
ncol(list_seurat[["P5CRC"]])
ncol(list_seurat[["P5NAT"]])
```

The sum of these values is

```{r}
541968 + 435773
```

Which is the same as the number of samples in our Seurat callout!

```{r}
seurat_merged
```

If we look at the metadata of the merged object we should be able to see the prefixes in the rownames (`Cells`) as well as the updated `orig.ident` we set in the for loop earlier.

```{r}
#| label: inspect_seurat_object
# Check that the merged object has the appropriate sample-specific prefixes
head(seurat_merged@meta.data)
tail(seurat_merged@meta.data)
```

::: callout-tip
# [**Exercise 3**](02_preprocessing-of-data_Answer-key.qmd#exercise-3)
TODO
Exercise 3
:::

# Save!

Now is a great spot to save our `seurat_merged` object as the next step is going to be filtering. 

```{r}
#| eval: false
# Save integrated Seurat object
saveRDS(seurat_merged, "data/seurat_merged.RDS")
```

A good rule of thumb is to save your intermediate objects before doing any filtration or after running a computational step that takes a long time to run.